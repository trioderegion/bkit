name: Extract Page
type: script
command: |-
  window.bkit ??= {
      MODULE_PREFIX: 'mm',
      prefix: '',
      moduleId: 'dnd-monster-manual'
    };
    
    
    async function promptContext() {

    
      
      const openActors = Object.values(ui.windows).filter( app => app.document?.documentName == 'JournalEntry' );
      const buttons = openActors.reduce( (acc, app) => {
        acc[app.document.uuid] = {
          label: `${app.document.name}`,
          callback: (html) => {
            const input = html[0].querySelector('#tlprefix');
            window.bkit.prefix = input.value;
            return {
              //docCls: ItemExtractor,
              prefix: `${window.bkit.MODULE_PREFIX}${input.value}`,
              pack: null,
              parent: app.document,
            }
          }}
       
        return acc;
      }, {});
    


      const response = Dialog.wait(
        {
          title: "Add to Open Journal",
          content: `<p><input id="tlprefix" type="text" placeholder="3-letter Prefix" value="${window.bkit.prefix}"></p>`,
          default: "cancel",
          buttons,
        },
        { classes: ["flexcol"] }
      );
    
      return response;
    }
    
    const getSelectionId = () => {
      const selection = window.getSelection();
    
      if (selection.type !== "Range") {
        ui.notifications.error("No Range selected for document extraction!");
        return;
      }
    
      /* get 'top' and 'bottom' ordered */
      if (selection.anchorOffset > selection.extentOffset) {
        ui.notifications.warn("Please select top to bottom.");
        return;
      }
    
      selection.modify("extend", "right", "lineboundary");
    
      const initialRange = selection.getRangeAt(0);
      const start =
        initialRange.commonAncestorContainer.nodeName == "P"
        ? initialRange.commonAncestorContainer
        : selection.anchorNode.parentElement;
    
      selection.setBaseAndExtent(
        start,
        0,
        selection.extentNode,
        selection.extentOffset
      );
    
      const fullRange = selection.getRangeAt(0);
    
      return {range: fullRange};
    }
    
    async function extractDocument() {
      
      const {range: fullRange = null} = getSelectionId();
      const fragment = fullRange.cloneContents();
    
      const wrapper = document.createElement("div");
      wrapper.appendChild(fragment);

      /* try to figure out where the name of the document lives */
      const nameFromChildren = (childNodes) => {
        while (childNodes.length > 0) {
          const node = childNodes[0];
          let nodeText = "";
          let nodeName = ""
          if (node.hasChildNodes()) {
            [nodeText, nodeName] = nameFromChildren(node.childNodes);
            if (!node.hasChildNodes()) node.remove();
          } else {
            /* trim name of whitespace and remove any trailing punctuation */
            nodeText = node.textContent.trim().replace(/[^\w\d\)]\.*$/, "");
            nodeName = node.parentElement.nodeName;
            node.remove();
          }
    
          if (nodeText.length > 0) {
            return [nodeText, nodeName];
          }
        }
      };
    
      let [name, tag] = nameFromChildren(wrapper.childNodes);
    
      if (name.length < 1) {
        ui.notifications.error(
          "Could not identify valid document name from selection"
        );
        return;
      }
    
      const context = await promptContext();
    
      if (!context) return;
   
      /* clean html */
      const unwrap = (element) => {
        element.childNodes?.forEach(unwrap);

        if (element.nodeName == 'DIV' &&
            element.childNodes.length == 1) {
           
            if( element.classList.value == '' ||
                 (element.childNodes[0].nodeName == 'DIV' &&
                element.childNodes[0].classList.value == element.classList.value)) {
          
              element.replaceWith(element.childNodes[0]);
            }

            
        }
      };
      
      wrapper.childNodes.forEach( unwrap );

    
      let description = wrapper.innerHTML.trim();
      
      const data = foundry.utils.expandObject({
        name,
        type: 'text',
        'text.content': description,
        'title.level': tag.at(0) == 'H' ? Number(tag.at(-1)) : 1,
        sort: (context.parent.pages.contents.at(-1)?.sort ?? 0) + CONST.SORT_INTEGER_DENSITY
      });

      await context.parent.createEmbeddedDocuments('JournalEntryPage', [data]);
      
    
    }
    
    extractDocument();
img: icons/svg/book.svg
author: xREoBzi7Iao0TR7B
scope: global
folder: omQP7IAQLxa0uKx5
ownership:
  default: 0
flags: {}
_stats:
  compendiumSource: null
  duplicateSource: null
  coreVersion: '13.348'
  systemId: dnd5e
  systemVersion: 4.2.0
  createdTime: 1733353180850
  modifiedTime: 1758207737465
  lastModifiedBy: xREoBzi7Iao0TR7B
  exportSource: null
_id: GUmF9TpYikfEJOBg
sort: 600000
_key: '!macros!GUmF9TpYikfEJOBg'
