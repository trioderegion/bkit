name: Extract Actor
type: script
command: |-
  window.bkit ??= {
    MODULE_PREFIX: 'phb',
    prefix: '',
    markers: {
      name: '.creature-name',
      score: '.single-score',
      meta: '.meta',
    },
  };

  function modulePacks(documentClasses = ["Actor"]) {
    const { packs } = game.modules.get("dnd-players-handbook");
    const ourPacks = packs
      .toObject()
      .filter((pack) => documentClasses.includes(pack.type));
    return ourPacks;
  }

  async function promptContext() {
    const ourPacks = modulePacks();

    const defaultButtons = {
      item: {
        label: "World Actor",
        callback: (html) => {
          const input = html[0].querySelector('#tlprefix');
          window.bkit.prefix = input.value;
          return {
            docCls: Actor.implementation,
            prefix: `${window.bkit.MODULE_PREFIX}${input.value}`,
            pack: null,
          }
        }
      },
      cancel: { label: "Cancel", callback: () => null },
    };

    const buttons = ourPacks.reduce((acc, info) => {
      acc[info.name] = {
        label: info.label,
        callback: (html) => {
          const input = html[0].querySelector('#tlprefix');
          window.bkit.prefix = input.value;
          return {
            docCls: CONFIG[info.type].documentClass,
            prefix: `${window.bkit.MODULE_PREFIX}${input.value}`,
            pack: info.id,
          }
        },
      };

      return acc;
    }, {});

    Reflect.ownKeys(defaultButtons).forEach(
      (id) => (buttons[id] = defaultButtons[id])
    );

    const response = Dialog.wait(
      {
        title: "Add to compendium",
        content: `<p><input id="tlprefix" type="text" placeholder="3-letter Prefix" value="${window.bkit.prefix}"></p>`,
        default: "cancel",
        buttons,
      },
      { classes: ["flexcol"] }
    );

    return response;
  }

  const getSelectionId = () => {
    const selection = window.getSelection();

    if (selection.type !== "Range") {
      ui.notifications.error("No Range selected for document extraction!");
      return;
    }

    /* get 'top' and 'bottom' ordered */
    if (selection.anchorOffset > selection.extentOffset) {
      ui.notifications.warn("Please select top to bottom.");
      return;
    }

    selection.modify("extend", "right", "lineboundary");

    const initialRange = selection.getRangeAt(0);
    const start =
      initialRange.commonAncestorContainer.nodeName == "P"
      ? initialRange.commonAncestorContainer
      : selection.anchorNode.parentElement;

    selection.setBaseAndExtent(
      start,
      0,
      selection.extentNode,
      selection.extentOffset
    );

    const fullRange = selection.getRangeAt(0);

    return {range: fullRange};
  }

  async function extractDocument() {
    
    const {range: fullRange = null} = getSelectionId();
    const fragment = fullRange.cloneContents();

    const wrapper = document.createElement("div");
    wrapper.appendChild(fragment);

    const nameNode = wrapper.querySelector(window.bkit.markers.name);

    if (!nameNode) {
      ui.notifications.error(
        "Could not identify valid creature name from selection"
      );
      return;
    }

    const name = nameNode.textContent;

    const scoreNodes = wrapper.querySelectorAll(window.bkit.markers.score);

    if (scoreNodes?.length == 0) {
      ui.notifications.error(
        "Could not identify valid creature ability scores from selection"
      );
      return;
    }

    const scores = {};
    const scoreRegex = /\s*(?<abil>(str|dex|con|int|wis|cha))\s*(?<score>\d+)/i
    for (const score of scoreNodes) {
      const result = scoreRegex.exec(score.textContent);
      scores[result.groups.abil.toLowerCase()] = { value: Number(result.groups.score) };
    }

    let metaNode = wrapper.querySelector(window.bkit.markers.meta);

    /* If not found, try using the line after the creature's name */
    if (!metaNode) {
      metaNode = nameNode.nextElementSibling;
    }

    const metaRegex = /\s*(?<size>\w+)(\s+or\s+\w+)?\s+(?<type>\w+)[^\w]+(?<align>\w+)/i
    const metaResult = metaRegex.exec(metaNode.textContent);
    const alignment = metaResult?.groups.align;
    const size = Reflect.ownKeys(CONFIG.DND5E.actorSizes).find( key => CONFIG.DND5E.actorSizes[key].label == metaResult?.groups.size );
    const creatureType = Reflect.ownKeys(CONFIG.DND5E.creatureTypes).find( key => CONFIG.DND5E.creatureTypes[key].label == metaResult?.groups.type);

    const context = await promptContext();

    if (!context) return;

    /* if a non <p> is the remaining first child, its likely an inline item */
    if (!['H1', 'H2', 'H3', 'P'].includes(wrapper.firstChild.nodeName)) {
      const parawrapper = document.createElement("p");
      parawrapper.replaceChildren(...wrapper.childNodes);
      wrapper.replaceChildren(parawrapper);
    }

    const description = wrapper.innerHTML.trim();

    const data = foundry.utils.expandObject({
      name,
      type: 'npc',
      "system.details.biography.value": description,
      "system.details.alignment": alignment,
      "system.details.type.value": creatureType,
      "system.abilities": scores,
      "system.traits.size": size,
      _id: dnd5e.utils.staticID(`${context.prefix}${name.slugify({lowercase: false, replacement: '', strict: true})}`),
    });

    const cls = context.docCls;
    context.keepId = true;

    delete context.docCls;
    delete context.prefix;
    //console.log(data, context);
    await cls.create(data, context);

  }

  extractDocument();
img: icons/svg/thrust.svg
author: UkXd4NXnT5o2bQiL
scope: global
folder: null
ownership:
  default: 0
  UkXd4NXnT5o2bQiL: 3
flags: {}
_stats:
  compendiumSource: null
  duplicateSource: null
  coreVersion: '12.331'
  systemId: dnd5e
  systemVersion: 4.0.4
  createdTime: 1728322035835
  modifiedTime: 1728322061077
  lastModifiedBy: UkXd4NXnT5o2bQiL
_id: rptKSgOU3V7g3NFc
sort: 1100000
_key: '!macros!rptKSgOU3V7g3NFc'

